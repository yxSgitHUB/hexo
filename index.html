<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/hexo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo/css/main.css">


<link rel="stylesheet" href="/hexo/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yxsgithub.github.io","root":"/hexo/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="振翅">
<meta property="og:type" content="website">
<meta property="og:title" content="Moonkin&#39;s Hexo">
<meta property="og:url" content="https://yxsgithub.github.io/hexo/index.html">
<meta property="og:site_name" content="Moonkin&#39;s Hexo">
<meta property="og:description" content="振翅">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="yuxiao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yxsgithub.github.io/hexo/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Moonkin's Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Moonkin's Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">振翅</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/hexo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/hexo/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2025/06/09/TypeScript%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2025/06/09/TypeScript%E5%B0%8F%E8%AF%BE%E5%A0%82%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">TypeScript小课堂（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-09 10:34:11 / 修改时间：11:18:27" itemprop="dateCreated datePublished" datetime="2025-06-09T10:34:11+08:00">2025-06-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="我们为什么要使用-TS"><a href="#我们为什么要使用-TS" class="headerlink" title="我们为什么要使用 TS"></a>我们为什么要使用 TS</h2><h3 id="提升代码可读性与理解效率"><a href="#提升代码可读性与理解效率" class="headerlink" title="提升代码可读性与理解效率"></a>提升代码可读性与理解效率</h3><h4 id="类型注解提供明确指引：在团队开发中，TypeScript-的类型注解为代码添加了清晰的文档说明。当其他成员阅读代码时，无需花费大量时间猜测变量、函数参数或返回值的类型，例如，function-getUserInfo-userId-string-UserInfo-，明确指出该函数接收字符串类型的-userId-参数并返回-UserInfo-类型，有助于快速理解代码逻辑与数据流。"><a href="#类型注解提供明确指引：在团队开发中，TypeScript-的类型注解为代码添加了清晰的文档说明。当其他成员阅读代码时，无需花费大量时间猜测变量、函数参数或返回值的类型，例如，function-getUserInfo-userId-string-UserInfo-，明确指出该函数接收字符串类型的-userId-参数并返回-UserInfo-类型，有助于快速理解代码逻辑与数据流。" class="headerlink" title="类型注解提供明确指引：在团队开发中，TypeScript 的类型注解为代码添加了清晰的文档说明。当其他成员阅读代码时，无需花费大量时间猜测变量、函数参数或返回值的类型，例如，function getUserInfo(userId: string): UserInfo ，明确指出该函数接收字符串类型的 userId 参数并返回 UserInfo 类型，有助于快速理解代码逻辑与数据流。"></a>类型注解提供明确指引：在团队开发中，TypeScript 的类型注解为代码添加了清晰的文档说明。当其他成员阅读代码时，无需花费大量时间猜测变量、函数参数或返回值的类型，例如，function getUserInfo(userId: string): UserInfo ，明确指出该函数接收字符串类型的 userId 参数并返回 UserInfo 类型，有助于快速理解代码逻辑与数据流。</h4><h4 id="避免类型误解的错误解读-：没有类型定义的代码可能因开发者对数据类型的误解导致错误，阻碍团队协作。TypeScript-的类型检查在代码编写阶段就避免这类问题，减少团队成员之间因理解不一致产生的沟通成本和协作障碍。"><a href="#避免类型误解的错误解读-：没有类型定义的代码可能因开发者对数据类型的误解导致错误，阻碍团队协作。TypeScript-的类型检查在代码编写阶段就避免这类问题，减少团队成员之间因理解不一致产生的沟通成本和协作障碍。" class="headerlink" title="避免类型误解的错误解读 ：没有类型定义的代码可能因开发者对数据类型的误解导致错误，阻碍团队协作。TypeScript 的类型检查在代码编写阶段就避免这类问题，减少团队成员之间因理解不一致产生的沟通成本和协作障碍。"></a>避免类型误解的错误解读 ：没有类型定义的代码可能因开发者对数据类型的误解导致错误，阻碍团队协作。TypeScript 的类型检查在代码编写阶段就避免这类问题，减少团队成员之间因理解不一致产生的沟通成本和协作障碍。</h4><h3 id="强有力的代码检查与安全性"><a href="#强有力的代码检查与安全性" class="headerlink" title="强有力的代码检查与安全性"></a>强有力的代码检查与安全性</h3><h4 id="提前发现潜在错误：通过静态类型检查，TypeScript-在编译阶段就能发现许多在-JavaScript-中需要等到运行时才能暴露的问题。例如，将字符串类型的值赋给预期为数字的变量，或调用函数时传递了错误类型的参数，开发团队能够在代码整合之前就修复这些错误，避免上线后因这些低级错误导致系统崩溃或功能异常影响用户体验，提升团队开发效率和项目质量。"><a href="#提前发现潜在错误：通过静态类型检查，TypeScript-在编译阶段就能发现许多在-JavaScript-中需要等到运行时才能暴露的问题。例如，将字符串类型的值赋给预期为数字的变量，或调用函数时传递了错误类型的参数，开发团队能够在代码整合之前就修复这些错误，避免上线后因这些低级错误导致系统崩溃或功能异常影响用户体验，提升团队开发效率和项目质量。" class="headerlink" title="提前发现潜在错误：通过静态类型检查，TypeScript 在编译阶段就能发现许多在 JavaScript 中需要等到运行时才能暴露的问题。例如，将字符串类型的值赋给预期为数字的变量，或调用函数时传递了错误类型的参数，开发团队能够在代码整合之前就修复这些错误，避免上线后因这些低级错误导致系统崩溃或功能异常影响用户体验，提升团队开发效率和项目质量。"></a>提前发现潜在错误：通过静态类型检查，TypeScript 在编译阶段就能发现许多在 JavaScript 中需要等到运行时才能暴露的问题。例如，将字符串类型的值赋给预期为数字的变量，或调用函数时传递了错误类型的参数，开发团队能够在代码整合之前就修复这些错误，避免上线后因这些低级错误导致系统崩溃或功能异常影响用户体验，提升团队开发效率和项目质量。</h4><h4 id="维护项目稳定性-：随着项目规模扩大和团队成员增多，代码的修改和扩展频繁。TypeScript-的类型系统保障了代码的稳定性，当修改代码时，编译器会检查修改是否影响了依赖于原有类型定义的其他部分，确保改动在安全范围内，降低团队协作中因代码变更引发的隐藏风险。"><a href="#维护项目稳定性-：随着项目规模扩大和团队成员增多，代码的修改和扩展频繁。TypeScript-的类型系统保障了代码的稳定性，当修改代码时，编译器会检查修改是否影响了依赖于原有类型定义的其他部分，确保改动在安全范围内，降低团队协作中因代码变更引发的隐藏风险。" class="headerlink" title="维护项目稳定性 ：随着项目规模扩大和团队成员增多，代码的修改和扩展频繁。TypeScript 的类型系统保障了代码的稳定性，当修改代码时，编译器会检查修改是否影响了依赖于原有类型定义的其他部分，确保改动在安全范围内，降低团队协作中因代码变更引发的隐藏风险。"></a>维护项目稳定性 ：随着项目规模扩大和团队成员增多，代码的修改和扩展频繁。TypeScript 的类型系统保障了代码的稳定性，当修改代码时，编译器会检查修改是否影响了依赖于原有类型定义的其他部分，确保改动在安全范围内，降低团队协作中因代码变更引发的隐藏风险。</h4><h3 id="便于代码维护与拓展"><a href="#便于代码维护与拓展" class="headerlink" title="便于代码维护与拓展"></a>便于代码维护与拓展</h3><h4 id="简化代码重构过程-：在团队长期维护项目过程中，经常需要对代码进行重构以优化性能、提升可读性或添加新功能。TypeScript-的类型定义使得重构更为安全高效，开发者可以放心地重命名变量、修改函数签名或调整类结构，编译器会实时提示相关错误，避免因重构导致大量难以追踪的运行时错误，提高团队对遗留代码的维护信心和效率。"><a href="#简化代码重构过程-：在团队长期维护项目过程中，经常需要对代码进行重构以优化性能、提升可读性或添加新功能。TypeScript-的类型定义使得重构更为安全高效，开发者可以放心地重命名变量、修改函数签名或调整类结构，编译器会实时提示相关错误，避免因重构导致大量难以追踪的运行时错误，提高团队对遗留代码的维护信心和效率。" class="headerlink" title="简化代码重构过程 ：在团队长期维护项目过程中，经常需要对代码进行重构以优化性能、提升可读性或添加新功能。TypeScript 的类型定义使得重构更为安全高效，开发者可以放心地重命名变量、修改函数签名或调整类结构，编译器会实时提示相关错误，避免因重构导致大量难以追踪的运行时错误，提高团队对遗留代码的维护信心和效率。"></a>简化代码重构过程 ：在团队长期维护项目过程中，经常需要对代码进行重构以优化性能、提升可读性或添加新功能。TypeScript 的类型定义使得重构更为安全高效，开发者可以放心地重命名变量、修改函数签名或调整类结构，编译器会实时提示相关错误，避免因重构导致大量难以追踪的运行时错误，提高团队对遗留代码的维护信心和效率。</h4><h4 id="支持灵活的项目扩展-：当团队需要为项目添加新功能模块或与其他系统集成时，TypeScript-的类型系统提供了清晰的接口规范。新成员能够依据这些接口快速开发和整合代码，减少因不了解项目原有数据结构和业务逻辑而产生的错误，同时原有代码的类型安全保障了新功能与旧代码的顺利融合。"><a href="#支持灵活的项目扩展-：当团队需要为项目添加新功能模块或与其他系统集成时，TypeScript-的类型系统提供了清晰的接口规范。新成员能够依据这些接口快速开发和整合代码，减少因不了解项目原有数据结构和业务逻辑而产生的错误，同时原有代码的类型安全保障了新功能与旧代码的顺利融合。" class="headerlink" title="支持灵活的项目扩展 ：当团队需要为项目添加新功能模块或与其他系统集成时，TypeScript 的类型系统提供了清晰的接口规范。新成员能够依据这些接口快速开发和整合代码，减少因不了解项目原有数据结构和业务逻辑而产生的错误，同时原有代码的类型安全保障了新功能与旧代码的顺利融合。"></a>支持灵活的项目扩展 ：当团队需要为项目添加新功能模块或与其他系统集成时，TypeScript 的类型系统提供了清晰的接口规范。新成员能够依据这些接口快速开发和整合代码，减少因不了解项目原有数据结构和业务逻辑而产生的错误，同时原有代码的类型安全保障了新功能与旧代码的顺利融合。</h4><h3 id="增强团队协作与沟通"><a href="#增强团队协作与沟通" class="headerlink" title="增强团队协作与沟通"></a>增强团队协作与沟通</h3><h4 id="统一团队开发标准与规范-：TypeScript-的引入促使团队制定统一的类型定义规范、代码风格和项目结构，减少因个人开发习惯差异带来的混乱。例如，规定接口命名规则、类型声明格式等，使团队成员在协作开发时能够按照一致的标准编写和审核代码，提高代码质量和团队协作的流畅性。"><a href="#统一团队开发标准与规范-：TypeScript-的引入促使团队制定统一的类型定义规范、代码风格和项目结构，减少因个人开发习惯差异带来的混乱。例如，规定接口命名规则、类型声明格式等，使团队成员在协作开发时能够按照一致的标准编写和审核代码，提高代码质量和团队协作的流畅性。" class="headerlink" title="统一团队开发标准与规范 ：TypeScript 的引入促使团队制定统一的类型定义规范、代码风格和项目结构，减少因个人开发习惯差异带来的混乱。例如，规定接口命名规则、类型声明格式等，使团队成员在协作开发时能够按照一致的标准编写和审核代码，提高代码质量和团队协作的流畅性。"></a>统一团队开发标准与规范 ：TypeScript 的引入促使团队制定统一的类型定义规范、代码风格和项目结构，减少因个人开发习惯差异带来的混乱。例如，规定接口命名规则、类型声明格式等，使团队成员在协作开发时能够按照一致的标准编写和审核代码，提高代码质量和团队协作的流畅性。</h4><h4 id="促进跨团队交流与共享-：在大型项目中，不同团队可能负责不同模块的开发。TypeScript-的类型定义文件（-d-ts）便于团队之间共享类型信息，当一个团队开发的库或组件被其他团队使用时，类型定义文件确保其他团队成员能够正确理解和使用该库，避免因类型不明确导致的使用错误，促进团队间的协作和代码复用。"><a href="#促进跨团队交流与共享-：在大型项目中，不同团队可能负责不同模块的开发。TypeScript-的类型定义文件（-d-ts）便于团队之间共享类型信息，当一个团队开发的库或组件被其他团队使用时，类型定义文件确保其他团队成员能够正确理解和使用该库，避免因类型不明确导致的使用错误，促进团队间的协作和代码复用。" class="headerlink" title="促进跨团队交流与共享 ：在大型项目中，不同团队可能负责不同模块的开发。TypeScript 的类型定义文件（.d.ts）便于团队之间共享类型信息，当一个团队开发的库或组件被其他团队使用时，类型定义文件确保其他团队成员能够正确理解和使用该库，避免因类型不明确导致的使用错误，促进团队间的协作和代码复用。"></a>促进跨团队交流与共享 ：在大型项目中，不同团队可能负责不同模块的开发。TypeScript 的类型定义文件（.d.ts）便于团队之间共享类型信息，当一个团队开发的库或组件被其他团队使用时，类型定义文件确保其他团队成员能够正确理解和使用该库，避免因类型不明确导致的使用错误，促进团队间的协作和代码复用。</h4><h3 id="强大的工具支持与开发效率提升"><a href="#强大的工具支持与开发效率提升" class="headerlink" title="强大的工具支持与开发效率提升"></a>强大的工具支持与开发效率提升</h3><h4 id="智能代码补全与提示-：TypeScript-搭配现代-IDE（如-Visual-Studio-Code）能够提供智能的代码补全、参数提示和类型信息显示功能。在团队协作编写代码时，成员可以快速获取可用的属性、方法和类型信息，减少因记忆模糊或不熟悉代码库而花费的时间，提高编码速度和准确性，提升团队整体开发效率。"><a href="#智能代码补全与提示-：TypeScript-搭配现代-IDE（如-Visual-Studio-Code）能够提供智能的代码补全、参数提示和类型信息显示功能。在团队协作编写代码时，成员可以快速获取可用的属性、方法和类型信息，减少因记忆模糊或不熟悉代码库而花费的时间，提高编码速度和准确性，提升团队整体开发效率。" class="headerlink" title="智能代码补全与提示 ：TypeScript 搭配现代 IDE（如 Visual Studio Code）能够提供智能的代码补全、参数提示和类型信息显示功能。在团队协作编写代码时，成员可以快速获取可用的属性、方法和类型信息，减少因记忆模糊或不熟悉代码库而花费的时间，提高编码速度和准确性，提升团队整体开发效率。"></a>智能代码补全与提示 ：TypeScript 搭配现代 IDE（如 Visual Studio Code）能够提供智能的代码补全、参数提示和类型信息显示功能。在团队协作编写代码时，成员可以快速获取可用的属性、方法和类型信息，减少因记忆模糊或不熟悉代码库而花费的时间，提高编码速度和准确性，提升团队整体开发效率。</h4><h4 id="代码导航与重构工具-：借助-TypeScript-的高级工具支持，如代码导航（跳转到定义、查找引用）、批量重命名等，团队成员能够轻松地在大型代码库中定位和修改代码。这些工具在团队协作开发过程中，特别是在进行跨文件、跨模块的代码变更时，显著节省时间，提高团队对代码的掌控力和开发协同性。"><a href="#代码导航与重构工具-：借助-TypeScript-的高级工具支持，如代码导航（跳转到定义、查找引用）、批量重命名等，团队成员能够轻松地在大型代码库中定位和修改代码。这些工具在团队协作开发过程中，特别是在进行跨文件、跨模块的代码变更时，显著节省时间，提高团队对代码的掌控力和开发协同性。" class="headerlink" title="代码导航与重构工具 ：借助 TypeScript 的高级工具支持，如代码导航（跳转到定义、查找引用）、批量重命名等，团队成员能够轻松地在大型代码库中定位和修改代码。这些工具在团队协作开发过程中，特别是在进行跨文件、跨模块的代码变更时，显著节省时间，提高团队对代码的掌控力和开发协同性。"></a>代码导航与重构工具 ：借助 TypeScript 的高级工具支持，如代码导航（跳转到定义、查找引用）、批量重命名等，团队成员能够轻松地在大型代码库中定位和修改代码。这些工具在团队协作开发过程中，特别是在进行跨文件、跨模块的代码变更时，显著节省时间，提高团队对代码的掌控力和开发协同性。</h4><h2 id="TS-基础"><a href="#TS-基础" class="headerlink" title="TS 基础"></a>TS 基础</h2><h3 id="网上-TS-教程有很多，这里就不再赘述"><a href="#网上-TS-教程有很多，这里就不再赘述" class="headerlink" title="网上 TS 教程有很多，这里就不再赘述"></a>网上 TS 教程有很多，这里就不再赘述</h3><p>有的同学在写 TS 会担心，说我不会类型体操，也不会泛型，不写 any 就报错，那我如何去写 TS 呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">InternalSelectProps</span>&lt;</span><br><span class="line">  <span class="title class_">ValueType</span> = <span class="built_in">any</span>,</span><br><span class="line">  <span class="title class_">OptionType</span> <span class="keyword">extends</span> <span class="title class_">BaseOptionType</span> | <span class="title class_">DefaultOptionType</span> = <span class="title class_">DefaultOptionType</span>,</span><br><span class="line">&gt; <span class="keyword">extends</span> <span class="title class_">Omit</span>&lt;<span class="title class_">RcSelectProps</span>&lt;<span class="title class_">ValueType</span>, <span class="title class_">OptionType</span>&gt;, &#x27;mode&#x27;&gt; &#123;</span><br><span class="line">  <span class="attr">rootClassName</span>?: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">prefix</span>?: <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">  <span class="attr">suffixIcon</span>?: <span class="title class_">React</span>.<span class="property">ReactNode</span>;</span><br><span class="line">  <span class="attr">size</span>?: <span class="title class_">SizeType</span>;</span><br><span class="line">  <span class="attr">disabled</span>?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">mode</span>?: <span class="string">&#x27;multiple&#x27;</span> | <span class="string">&#x27;tags&#x27;</span> | <span class="string">&#x27;SECRET_COMBOBOX_MODE_DO_NOT_USE&#x27;</span> | <span class="string">&#x27;combobox&#x27;</span>;</span><br><span class="line">  <span class="comment">/** <span class="doctag">@deprecated</span> Use `variant` instead. */</span></span><br><span class="line">  <span class="attr">bordered</span>?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@deprecated</span> `showArrow` is deprecated which will be removed in next major version. It will be a</span></span><br><span class="line"><span class="comment">   *   default behavior, you can hide it by setting `suffixIcon` to null.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">showArrow</span>?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span> 5.13.0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@default</span> &quot;outlined&quot;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">variant</span>?: <span class="title class_">Variant</span>;</span><br><span class="line">  <span class="attr">styles</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Record</span>&lt;<span class="title class_">SemanticName</span>, <span class="title class_">React</span>.<span class="property">CSSProperties</span>&gt;&gt; &amp; &#123;</span><br><span class="line">    <span class="attr">popup</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Record</span>&lt;<span class="title class_">PopupSemantic</span>, <span class="title class_">React</span>.<span class="property">CSSProperties</span>&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="attr">classNames</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Record</span>&lt;<span class="title class_">SemanticName</span>, <span class="built_in">string</span>&gt;&gt; &amp; &#123;</span><br><span class="line">    <span class="attr">popup</span>?: <span class="title class_">Partial</span>&lt;<span class="title class_">Record</span>&lt;<span class="title class_">PopupSemantic</span>, <span class="built_in">string</span>&gt;&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何去写"><a href="#如何去写" class="headerlink" title="如何去写"></a>如何去写</h3><p>首先 一口气吃不成胖子，先把基础类型定义搞清楚你就学会了一半了。<br>TS 的能力在我看来是用来约束，js 的特性就是灵活，而 ts 则是约束这份灵活，让你在写代码的时候，能够更安全，更方便。<br>所以我们在写代码的时候先要确定哪些是比较固定的，不由我们的意志为转移的</p>
<h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><p>不论是第三方接口还是后端接口，在除开开发阶段的时候，大部分都是比较稳定的，开发阶段也可以提前约定来进行 TS 类型的声明</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserPermission</span> = &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">permission</span>: <span class="built_in">number</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserStore</span> = &#123;</span><br><span class="line">  <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span>;</span><br><span class="line">  <span class="attr">userPermission</span>: <span class="title class_">UserPermission</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个阶段中，返回类型通常是固定的，所以可以尽量写的紧一些</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PermissionCode</span> = <span class="number">10001</span>｜<span class="number">10002</span>｜<span class="number">10003</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserPermission</span> = &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="attr">permission</span>: <span class="title class_">PermissionCode</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserStore</span> = &#123;</span><br><span class="line">  <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span>;</span><br><span class="line">  <span class="attr">userPermission</span>: <span class="title class_">UserPermission</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进一步 抽出常量</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PERMISSION_CODE</span> = &#123;</span><br><span class="line">  <span class="number">10001</span>: <span class="string">&#x27;查看&#x27;</span>,</span><br><span class="line">  <span class="number">10002</span>: <span class="string">&#x27;编辑&#x27;</span>,</span><br><span class="line">  <span class="number">10003</span>: <span class="string">&#x27;删除&#x27;</span>,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PermissionCode</span> = keyof <span class="keyword">typeof</span> <span class="variable constant_">PERMISSION_CODE</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInfo</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserPermission</span> = &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&quot;admin&quot;</span> | <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    <span class="attr">permission</span>: <span class="title class_">PermissionCode</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserStore</span> = &#123;</span><br><span class="line">  <span class="attr">userInfo</span>: <span class="title class_">UserInfo</span>;</span><br><span class="line">  <span class="attr">userPermission</span>: <span class="title class_">UserPermission</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做到这种程度我觉得基本数据定义已经没什么问题了<br>然后我们就可以开始通过数据来构造我们的页面了<br>但是问题又来了</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span> = &#123;</span><br><span class="line">  <span class="attr">field</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;=&quot;</span>  | <span class="string">&quot;!=&quot;</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;|&#123;</span><br><span class="line">  <span class="attr">field</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> | <span class="string">&quot;&lt;=&quot;</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Logic</span> = &#123;</span><br><span class="line">  <span class="attr">logic</span>:<span class="string">&quot;or&quot;</span> | <span class="string">&quot;and&quot;</span></span><br><span class="line">  <span class="attr">filter</span>: <span class="title class_">Filter</span>[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通常会遇到一些比较复杂的数据<br>比如 如何判断一个节点是逻辑节点还是叶子节点呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NormalFilter</span> = &#123;</span><br><span class="line">  <span class="attr">field</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;=&quot;</span>  | <span class="string">&quot;!=&quot;</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NumberFilter</span> = &#123;</span><br><span class="line">  <span class="attr">field</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">operator</span>: <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> | <span class="string">&quot;&lt;=&quot;</span>;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filter</span> = <span class="title class_">NormalFilter</span> | <span class="title class_">NumberFilter</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Logic</span> = &#123;</span><br><span class="line">  <span class="attr">logic</span>:<span class="string">&quot;or&quot;</span> | <span class="string">&quot;and&quot;</span></span><br><span class="line">  <span class="attr">filter</span>: <span class="title class_">Filter</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isLogic = (<span class="attr">node</span>: <span class="title class_">Filter</span> | <span class="title class_">Logic</span>): node is <span class="title class_">Logic</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;logic&#x27;</span> <span class="keyword">in</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> isNumberFilter = (<span class="attr">filter</span>:<span class="title class_">Filter</span>): filter is <span class="title class_">NumberFilter</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;operator&#x27;</span> <span class="keyword">in</span> filter &amp;&amp; [ <span class="string">&quot;&gt;&quot;</span> ,<span class="string">&quot;&lt;&quot;</span> , <span class="string">&quot;&gt;=&quot;</span> , <span class="string">&quot;&lt;=&quot;</span>].<span class="title function_">includes</span>(filter.<span class="property">operator</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok,那么掌握到这种程度，基本已经可以写一些简单的页面了<br>但是如果我们遇到一些比较复杂的页面，我们就需要考虑一下进阶写法<br>我们下期再见</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/10/28/cypress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/10/28/cypress/" class="post-title-link" itemprop="url">cypress</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-28 11:01:18" itemprop="dateCreated datePublished" datetime="2021-10-28T11:01:18+08:00">2021-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="cypress简介"><a href="#cypress简介" class="headerlink" title="cypress简介"></a>cypress简介</h2><p>cypressjs是一个非常强大的测试工具，之前分享过使用jest来进行测试，与jest不同的是cypress可以不侵入代码进行测试</p>
<p>以往我们写单元测试的时候，需要直接侵入代码，通过调用组件等形式进行组件级别的测试，但是通过使用cypress，我们可以通过一种模拟测试人员行为的方案来进行测试，甚至在离开项目源代码的基础上进行测试</p>
<h2 id="cypress使用"><a href="#cypress使用" class="headerlink" title="cypress使用"></a>cypress使用</h2><p>在这里我们采取独立新建测试项目的方式来进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir cypressdemo</span><br><span class="line">npm init</span><br><span class="line">cnpm install cypress --save-dev</span><br></pre></td></tr></table></figure>

<p>这样我们就有了一个基础的cypress项目</p>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cypress open</span><br></pre></td></tr></table></figure>

<p>就可以启动cypress的图形化界面，如图</p>
<img src="/hexo/2021/10/28/cypress/WX20211028-111230.png" class="">

<p>选择对应的脚本，就会自动打开浏览器进行测试</p>
<h2 id="cypress控件指北"><a href="#cypress控件指北" class="headerlink" title="cypress控件指北"></a>cypress控件指北</h2><p>在”/cypress/support/index.js“中，我们可以声明一些自定义的命令以及第三方封装好的命令</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./commands&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;cypress-xpath&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;cypress-wait-until&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>其中自定义命令为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cypress</span>.<span class="property">Commands</span>.<span class="title function_">add</span>(<span class="string">&quot;login&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> config = <span class="title class_">Cypress</span>.<span class="title function_">config</span>();</span><br><span class="line">  cy.<span class="title function_">setCookie</span>(<span class="string">&quot;connect.sid&quot;</span>, config.<span class="property">userCookie</span>);</span><br><span class="line">  cy.<span class="title function_">visit</span>(<span class="string">&quot;/dashboard&quot;</span>);</span><br><span class="line">  cy.<span class="title function_">viewport</span>(<span class="number">1920</span>, <span class="number">1080</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就添加了一个自定义的登录命令</p>
<p>在测试脚本中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.<span class="title function_">login</span>();</span><br></pre></td></tr></table></figure>

<p>产生的效果就是每次测试之前先注入用户的cookie</p>
<p>cypress-xpath的功能是帮助我们选择页面上的元素，右键元素选择复制xpath路径即可，使用方式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cy.xpath(&#x27;//nav[contains(@class,&quot;nav-column&quot;)]&#x27;).trigger(&quot;mouseover&quot;);</span><br></pre></td></tr></table></figure>

<p>cypress-wait-until则是一个等待工具，扩展了cypress的等待功能</p>
<p>可以等待接口返回之后进行下一步骤的操作</p>
<p>也可以等待固定时间</p>
<h2 id="cypress结果查询"><a href="#cypress结果查询" class="headerlink" title="cypress结果查询"></a>cypress结果查询</h2><p>cypress有自己的结果平台</p>
<p>在dashboard.cypress.io的网址下可以看到自己项目的一些情况，当然需要自己手动选择上报</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cypress run --record --key xxxxxxxxxxxx</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/09/26/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Enode%E5%86%99%E4%B8%80%E4%BA%9B%E5%B0%8F%E8%84%9A%E6%9C%AC%E4%BB%A5%E5%8F%8A%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/09/26/%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Enode%E5%86%99%E4%B8%80%E4%BA%9B%E5%B0%8F%E8%84%9A%E6%9C%AC%E4%BB%A5%E5%8F%8A%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">如何基于node写一些小脚本以及脚本工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-26 19:57:01" itemprop="dateCreated datePublished" datetime="2021-09-26T19:57:01+08:00">2021-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在日常开发过程中有很多重复性的操作，而且比较容易出错的操作可以通过脚本来实现</p>
<p>ps：通常情况下前端同学的脚本sh能力都比较弱，能够用js来执行一些想要的操作是比较理想的</p>
<p>而node就提供了这一能力</p>
<p>前提：node可以将一个js文件作为脚本进行运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node ./xx.js</span><br></pre></td></tr></table></figure>

<p>就可以直接执行代码</p>
<h3 id="简单的一个小需求"><a href="#简单的一个小需求" class="headerlink" title="简单的一个小需求"></a>简单的一个小需求</h3><p>今天写博客的时候突然发现自己有点呆</p>
<p>生成一篇新博客的命令是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post XXX</span><br></pre></td></tr></table></figure>

<p>这个xxx我写死为1，生成之后将1改成我想要的名字</p>
<h4 id="拆分需求"><a href="#拆分需求" class="headerlink" title="拆分需求"></a>拆分需求</h4><p>我希望一个脚本就能解决问题，不需要每次都采取文件名修改的方式</p>
<p>1 这个脚本应该可以询问我 博客标题</p>
<p>2 利用我输入的标题进行博客创建</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt.<span class="title function_">get</span>([<span class="string">&quot;postName&quot;</span>], <span class="keyword">function</span> (<span class="params">err, result</span>) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Log the results.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">postName</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个命令行交互采用了 <a target="_blank" rel="noopener" href="https://gitee.com/mirrors/node-prompt#usage">prompt</a></p>
<p>这个有很多极客的用法，比如选择，输入，密码等等一系列小黑框常见的交互，这里简单的采取了输入的方式</p>
<p>利用这个库我们可以拿到之前想要的输入 ，这个可以有多个，看需求</p>
<p>处理脚本的话采用node自带的 <a target="_blank" rel="noopener" href="http://nodejs.cn/api/child_process.html">child_process</a>子进程来进行处理</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>).<span class="property">exec</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&quot;hexo new post &quot;</span> + result.<span class="property">postName</span>, <span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取命令执行的输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>这样的话我们就能完成一个比较简单的脚本，运行之后输入一个名字，就能自动创建一篇空白博客</p>
<p>同理，我们自动触发构建镜像的git打tag操作也是这么做的，打完tag直接删除不留痕迹</p>
<p>用户只需要执行tag-push的命令，选择要构建的环境然后输入一点点描述即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/07/19/HTML%E4%B8%AD%E7%9A%84META%E6%A0%87%E7%AD%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/07/19/HTML%E4%B8%AD%E7%9A%84META%E6%A0%87%E7%AD%BE/" class="post-title-link" itemprop="url">HTML中的META标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-19 21:06:50" itemprop="dateCreated datePublished" datetime="2021-07-19T21:06:50+08:00">2021-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最早碰到这个标签的时候也是大部分童鞋遇到meta标签都是这个场景</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个是个通用标识，用来调节在移动端渲染时候的viewport，在pc端不生效</p>
<p>最近突然看到，其实meta标签还有其他的作用</p>
<p>元数据（Metadata）是数据的数据信息。</p>
<p><code>&lt;meta&gt;</code> 标签提供了 HTML 文档的元数据。元数据不会显示在客户端，但是会被浏览器解析。</p>
<p>META元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者及其他元数据。</p>
<p>元数据可以被使用浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 Web 服务调用。</p>
<h2 id="1-http-equiv-属性"><a href="#1-http-equiv-属性" class="headerlink" title="1. http-equiv 属性"></a>1. http-equiv 属性</h2><p><code>http-equiv</code>一般设置的都是与<code>http</code>请求头相关的信息，设置的值会关联到http头部。也就是说浏览器在请求服务器获取<code>html</code>的时候，服务器会将<code>html</code>中设置的<code>meta</code>放在响应头中返回给浏览器。常见的类型比如<code>content-type</code>, <code>expires</code>, <code>refresh</code>, <code>set-cookie</code>, <code>window-target</code>, <code>charset</code>， <code>pragma</code>等等。</p>
<h4 id="1-content-type"><a href="#1-content-type" class="headerlink" title="1. content-type"></a>1. content-type</h4><p>这样设置浏览器的头信息就会包含:content-type: text/html charset=utf8</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html charset=utf8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-expires"><a href="#2-expires" class="headerlink" title="2. expires"></a>2. expires</h4><p>用于设置浏览器的过期时间, 其实就是响应头中的expires属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;31 Dec 2021&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-refresh"><a href="#3-refresh" class="headerlink" title="3. refresh"></a>3. refresh</h4><p>该种设定表示5秒自动刷新并且跳转到指定的网页。如果不设置url的值那么浏览器则刷新本网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;5 url=http://www.zhiqianduan.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-window-target"><a href="#4-window-target" class="headerlink" title="4. window-target"></a>4. window-target</h4><p>强制页面在当前窗口以独立页面显示, 可以防止别人在框架中调用自己的页面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;window-target&quot;</span> <span class="attr">content</span>=<span class="string">&quot;_top&#x27;&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="5-pragma"><a href="#5-pragma" class="headerlink" title="5. pragma"></a>5. pragma</h4><p>禁止浏览器从本地计算机的缓存中访问页面的内容</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-name-属性"><a href="#2-name-属性" class="headerlink" title="2. name 属性"></a>2. name 属性</h2><p><code>name</code>属性主要用于描述网页，与对应的<code>content</code>中的内容主要是便于搜索引擎查找信息和分类信息用的, 用法与<code>http-equiv</code>相同，<code>name</code>设置属性名，<code>content</code>设置属性值。</p>
<h4 id="1-author"><a href="#1-author" class="headerlink" title="1. author"></a>1. author</h4><p><code>author</code>用来标注网页的作者</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;aaa@mail.abc.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-description"><a href="#2-description" class="headerlink" title="2. description"></a>2. description</h4><p><code>description</code>用来告诉搜素引擎当前网页的主要内容，是关于网站的一段描述信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是我的HTML&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-keywords"><a href="#3-keywords" class="headerlink" title="3. keywords"></a>3. keywords</h4><p><code>keywords</code>设置网页的关键字，来告诉浏览器关键字是什么。是一个经常被用到的名称。它为文档定义了一组关键字。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Hello world&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-generator"><a href="#4-generator" class="headerlink" title="4. generator"></a>4. generator</h4><p>表示当前<code>html</code>是用什么工具编写生成的，并没有实际作用，一般是编辑器自动创建的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;vscode&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-revised"><a href="#5-revised" class="headerlink" title="5. revised"></a>5. revised</h4><p>指定页面的最新版本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;revised&quot;</span> <span class="attr">content</span>=<span class="string">&quot;V2，2015/10/1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-robots"><a href="#6-robots" class="headerlink" title="6. robots"></a>6. robots</h4><p>告诉搜索引擎机器人抓取哪些页面，<code>all / none / index / noindex / follow / nofollow</code>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>all</code>：文件将被检索，且页面上的链接可以被查询； <code>none</code>：文件将不被检索，且页面上的链接不可以被查询； <code>index</code>：文件将被检索； <code>follow</code>：页面上的链接可以被查询； <code>noindex</code>：文件将不被检索，但页面上的链接可以被查询； <code>nofollow</code>：文件将不被检索，页面上的链接可以被查询。</p>
<h2 id="3-charset属性"><a href="#3-charset属性" class="headerlink" title="3. charset属性"></a>3. charset属性</h2><p>定义文档的字符编码。</p>
<h2 id="4-Scheme属性"><a href="#4-Scheme属性" class="headerlink" title="4. Scheme属性"></a>4. Scheme属性</h2><p>HTML5不支持。 定义用于翻译 content 属性值的格式。</p>
<h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-viewport补充"><a href="#6-viewport补充" class="headerlink" title="6.viewport补充"></a>6.viewport补充</h2><table>
<thead>
<tr>
<th>属性</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>设置**<em>layout viewport**</em> 的宽度，为一个正整数，或字符串”width-device”</td>
</tr>
<tr>
<td>initial-scale</td>
<td>设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>height</td>
<td>设置**<em>layout viewport**</em> 的高度，这个属性对我们并不重要，很少使用</td>
</tr>
<tr>
<td>user-scalable</td>
<td>是否允许用户进行缩放，值为 “no” 或 “yes”, no 代表不允许，yes 代表允许</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/06/28/%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84TS%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/06/28/%E5%85%B3%E4%BA%8E%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84TS%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC/" class="post-title-link" itemprop="url">关于组件设计中的TS自动推导</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-28 14:18:43" itemprop="dateCreated datePublished" datetime="2021-06-28T14:18:43+08:00">2021-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>我们首先从select组件开始</p>
<p>组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">type Option =&#123; key: string , title: string &#125;|&#123; key: number , title: string &#125;</span><br><span class="line">type SelectProps = &#123;</span><br><span class="line">  options: Option[];</span><br><span class="line">  value: string | number;</span><br><span class="line">  onChange: (value: string | number) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">export default class Select extends React.Component&lt;SelectProps, SelectProps&gt; &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;value,onChange,options&#125; = this.props;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;select value=&#123;value&#125; onChange=&#123;(e) =&gt; &#123;</span><br><span class="line">        const index = Number(e.target.value)</span><br><span class="line">        onChange(options[index].key)</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &#123;options.map((v:Option,index) =&gt; &#123;</span><br><span class="line">          return &lt;option key=&#123;v.key&#125; value=&#123;index&#125;&gt;&#123;v.title&#125;&lt;/option&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./App.css&#x27;;</span><br><span class="line">import Select from &quot;./Select&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [value, setValue] = useState&lt;string|number&gt;(&#x27;0&#x27;)</span><br><span class="line">  const onChange = (key: string|number) =&gt; &#123;</span><br><span class="line">    setValue(key);</span><br><span class="line">  &#125;</span><br><span class="line">  const options = [&#123;key:&#x27;0&#x27;,title:&#x27;0&#x27;&#125;,&#123;key:&#x27;1&#x27;,title:&#x27;1&#x27;&#125;,&#123;key:&#x27;2&#x27;,title:&#x27;2&#x27;&#125;,&#123;key:&#x27;3&#x27;,title:&#x27;3&#x27;&#125;]</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;Select value=&#123;value&#125; onChange=&#123;onChange&#125; options=&#123;options&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>这里举了一个最简单的select的例子</p>
<p>onChange的时候返回的key的类型应该是options的key的类型，但这个地方没有自动推导</p>
<p>这样的话就产生了很多问题</p>
<p>实际上在业务上，key一般都是很确定的唯一值，不能推导的话就显得很呆</p>
<p>这样的话让我们来改造一下，通过自动推导的方式和业务自己指定类型</p>
<p>组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">type Option =&#123; key: string | number, title: string &#125;</span><br><span class="line">type SelectProps&lt;O extends Option&gt; = &#123;</span><br><span class="line">  options: O[];</span><br><span class="line">  value: O[&#x27;key&#x27;];</span><br><span class="line">  onChange: (value:O[&#x27;key&#x27;]) =&gt; void;</span><br><span class="line">&#125;</span><br><span class="line">export default class Select&lt;O extends Option&gt; extends React.Component&lt;SelectProps&lt;O&gt;,SelectProps&lt;O&gt;&gt; &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; value, onChange, options &#125; = this.props;</span><br><span class="line">    const index = options.findIndex(v=&gt;v.key===value)</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &lt;select value=&#123;index&#125; onChange=&#123;(e) =&gt; &#123;</span><br><span class="line">        const index = Number(e.target.value)</span><br><span class="line">        onChange(options[index].key)</span><br><span class="line">      &#125;&#125;&gt;</span><br><span class="line">        &#123;options.map((v:Option,index) =&gt; &#123;</span><br><span class="line">          return &lt;option key=&#123;v.key&#125; value=&#123;index&#125;&gt;&#123;v.title&#125;&lt;/option&gt;</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#x27;./App.css&#x27;;</span><br><span class="line">import Select from &quot;./Select&quot;;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  const [value, setValue] = useState&lt;string&gt;(&#x27;0&#x27;)</span><br><span class="line">  const onChange = (key: string) =&gt; &#123;</span><br><span class="line">    setValue(key);</span><br><span class="line">  &#125;</span><br><span class="line">  const options = [&#123;key:&#x27;0&#x27;,title:&#x27;0&#x27;&#125;,&#123;key:&#x27;1&#x27;,title:&#x27;1&#x27;&#125;,&#123;key:&#x27;2&#x27;,title:&#x27;2&#x27;&#125;,&#123;key:&#x27;3&#x27;,title:&#x27;3&#x27;&#125;]</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;Select&lt;&#123;key:string,title:string&#125;&gt; value=&#123;value&#125; onChange=&#123;onChange&#125; options=&#123;options&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>通过这种形式，我们通过外部传入的Option类型来确认key的类型，这样就可以让类型更紧，更不容易出错，如果外部没有传入类型，也可进行自动推导，推导出option的类型</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="组件泛型"><a href="#组件泛型" class="headerlink" title="组件泛型"></a>组件泛型</h4><p>组件是可以使用一个泛型来进行类型的控制，我们定义的类型可以作为泛型的的最大范围，在这种情况下，可以复用组件逻辑，而不必去关心组件内参数的不同，而不用调用方去使用更加宽泛的类型来适应组件</p>
<p>以此类推。当我们在使用联合类型时，就可以使用这种方式，通过指定和外部传入来控制具体类型，使得类型推断更加精简以及准确</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/05/24/%E8%99%9A%E6%8B%9Fdom%E4%B9%8B%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/05/24/%E8%99%9A%E6%8B%9Fdom%E4%B9%8B%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">虚拟dom之操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 19:04:49" itemprop="dateCreated datePublished" datetime="2021-05-24T19:04:49+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="虚拟dom是什么"><a href="#虚拟dom是什么" class="headerlink" title="虚拟dom是什么"></a>虚拟dom是什么</h3><p>virtul DOM 也就是虚拟节点。通过JS的Object对象模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。</p>
<p>生成vNode—-&gt;渲染成真实节点 ———&gt;挂载到页面———&gt;diff比较</p>
<p>也就是说虚拟dom是在内存中存在，并不在页面上</p>
<h3 id="React中的dom操作"><a href="#React中的dom操作" class="headerlink" title="React中的dom操作"></a>React中的dom操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">export default class Input extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">      super(props);</span><br><span class="line">      this.state = &#123;</span><br><span class="line">          count:1</span><br><span class="line">      &#125;</span><br><span class="line">    this.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(&quot;componentDidUpdate&quot;,this.myRef);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.myRef);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div</span><br><span class="line">          ref=&#123;this.myRef&#125;</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">              console.log(this.myRef);</span><br><span class="line">              this.setState(state =&gt; &#123;</span><br><span class="line">                  state.count += 1;</span><br><span class="line">                  return state</span><br><span class="line">              &#125;)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          111111</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们用ref拿到reactNode，还可以使用document.getElement系列方法这里不展开。</p>
<p>通常ref是当节点渲染完成之后才能拿到的，也就是说，节点已经渲染到了页面上，这个时候再去操作dom就有些晚了，会造成页面的闪动</p>
<h3 id="hooks时代，这个问题有了新的解决方案"><a href="#hooks时代，这个问题有了新的解决方案" class="headerlink" title="hooks时代，这个问题有了新的解决方案"></a>hooks时代，这个问题有了新的解决方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default  function Index () &#123;</span><br><span class="line">    const ref = useRef();</span><br><span class="line">    </span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;useEffect&quot;,ref)</span><br><span class="line">        ref.current.style.transform = &quot;translateY(300px)&quot;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&#x27;animate&#x27;&gt;</span><br><span class="line">            &lt;div ref=&#123;ref&#125; className=&quot;square&quot; onClick=&#123;() =&gt; &#123;</span><br><span class="line">                 console.log(&quot;onClick&quot;,ref)</span><br><span class="line">                 ref.current.style.transform = &quot;translateY(0px)&quot;</span><br><span class="line">            &#125;&#125;&gt;square&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在hooks组件中执行有副作用的操作可以用useEffect来包裹，但是这样还是会有闪动的问题</p>
<p>但是在一次查看rc-overflow的源码时发现了一种新写法 useLayoutEffect</p>
<h3 id="useEffect和useLayoutEffect区别"><a href="#useEffect和useLayoutEffect区别" class="headerlink" title="useEffect和useLayoutEffect区别"></a>useEffect和useLayoutEffect区别</h3><p>摘抄了一点网上的说明：</p>
<h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>基本上90%的情况下,都应该用这个,这个是在render结束后,你的callback函数执行,但是不会block browser painting,算是某种异步的方式吧,但是class的componentDidMount 和componentDidUpdate是同步的,在render结束后就运行,useEffect在大部分场景下都比class的方式性能更好.</p>
<h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p>这个是用在处理DOM的时候,当你的useEffect里面的操作需要处理DOM,并且会改变页面的样式,就需要用这个,否则可能会出现出现闪屏问题, useLayoutEffect里面的callback函数会在DOM更新完成后立即执行,但是会在浏览器进行任何绘制之前运行完成,阻塞了浏览器的绘制.</p>
<p>也就是说useLayoutEffect会在虚拟dom在渲染成真实dom之前同步调用</p>
<p>这个方法可以相当于对虚拟dom进行操作</p>
<p>利用这个我们可以解决很多问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default  function Index () &#123;</span><br><span class="line">    const ref = useRef();</span><br><span class="line">    </span><br><span class="line">    useLayoutEffect(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;useEffect&quot;,ref)</span><br><span class="line">        ref.current.style.transform = &quot;translateY(300px)&quot;</span><br><span class="line">    &#125;, []);</span><br><span class="line">    return (</span><br><span class="line">        &lt;div className=&#x27;animate&#x27;&gt;</span><br><span class="line">            &lt;div ref=&#123;ref&#125; className=&quot;square&quot; onClick=&#123;() =&gt; &#123;</span><br><span class="line">                 console.log(&quot;onClick&quot;,ref)</span><br><span class="line">                 ref.current.style.transform = &quot;translateY(0px)&quot;</span><br><span class="line">            &#125;&#125;&gt;square&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次的实现，就是文字直接出现到了目标位置</p>
<p>但是代价就是白屏稍微长了一些</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在react16.8之后提供了react-hooks</p>
<p>其中的useLayoutEffect可以帮助我们同步的对dom进行一些操作</p>
<p>这能帮助我们可以以部分性能为代价实现某些dom计算操作</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/04/25/%E5%85%B3%E4%BA%8Etransform%E5%B8%A6%E6%9D%A5%E7%9A%84%E2%80%A6%E2%80%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/04/25/%E5%85%B3%E4%BA%8Etransform%E5%B8%A6%E6%9D%A5%E7%9A%84%E2%80%A6%E2%80%A6/" class="post-title-link" itemprop="url">关于transform带来的……</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-25 18:53:44" itemprop="dateCreated datePublished" datetime="2021-04-25T18:53:44+08:00">2021-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <img src="/hexo/2021/04/25/%E5%85%B3%E4%BA%8Etransform%E5%B8%A6%E6%9D%A5%E7%9A%84%E2%80%A6%E2%80%A6/WX20210425-185649@2x.png" class="">

<p>最近出现了这样一个问题，在table中，header在左右滑动的时候会闪动</p>
<p>审查元素时发现，元素位置是正确的但是没有渲染出来</p>
<p>这就引起了我的好奇，查阅资料之后做出如下总结</p>
<h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><p>浏览器是如何渲染一个页面？</p>
<p>在从服务器中拿到数据后，浏览器会先做解析三类东西：</p>
<ul>
<li>解析html,xhtml,svg这三类文档，形成dom树。</li>
<li>解析css，产生css rule tree。</li>
<li>解析js，js会通过api来操作dom tree和css rule tree。</li>
</ul>
<p>解析完成之后，浏览器引擎会通过dom tree和css rule tree来构建rendering tree：</p>
<ul>
<li>rendering tree和dom tree并不完全相同，例如：<head></head>或display:none的东西就不会放在渲染树中。</li>
<li>css rule tree主要是完成匹配，并把css rule附加给rendering tree的每个element。</li>
</ul>
<p>在渲染树构建完成后，</p>
<ul>
<li>浏览器会对这些元素进行定位和布局，这一步也叫做reflow或者layout。</li>
<li>浏览器绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做repaint。</li>
<li>然后浏览器会将各层的信息发送给GPU，GPU会将各层合成；显示在屏幕上。</li>
</ul>
<p>reflow =&gt; repaint =&gt; composite</p>
<p>浏览器渲染页面的任务由两个线程完成：主线程 和 排版线程</p>
<p>渲染过程：<br> 不同属性值引起的重新绘制有3种路径：</p>
<ol>
<li>layout-&gt;paint-&gt;composite</li>
<li>paint-&gt;composite</li>
<li>composite<br> CSS的属性也就此分为3大类：布局类（layout），绘制类（paint），合成类（composite）<br> composite 属性目前只有两个：transform和opacity</li>
</ol>
<h3 id="transform的机制和坑"><a href="#transform的机制和坑" class="headerlink" title="transform的机制和坑"></a>transform的机制和坑</h3><h4 id="机制："><a href="#机制：" class="headerlink" title="机制："></a>机制：</h4><ol>
<li>transform变换会在浏览器上单独创建一个绘画层并重新进行渲染</li>
<li>在动画的每一帧中，浏览器都要执行布局、 绘制、 以及将新的位图提交给 GPU。我们知道，将位图加载到 GPU 的内存中是一个相对较慢的操作。浏览器需要做大量工作的原因在于每一帧中元素的内容都在不断改变。改变一个元素的高度可能导致需要同步改变它的子元素的大小，所以浏览器必须重新计算布局。布局完成后，主线程又必须重新生成该元素的位图。</li>
</ol>
<h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><p>1.这样就产生了如图表格上的问题，表格的header过多的时候导致每次生成位图补不全或者不够时间完全传输到GPU，动画就会掉帧，表格的滚动本质上是监听scroll事件同步滚动的位置，，同时因为父元素还是在cpu计算，每次生成的时候还要频繁产生位图会卡顿并且动画掉帧</p>
<p>解决方案：为父元素添加transform:translate(0)</p>
<p>这样做的好处是，浏览器生成父元素以及headerItem的位图快照，之后位置就完全由GPU计算位置，不需要再和外部的header计算位移差，就节省了一大部分性能，然后就能顺滑的展示动画</p>
<p>2.当一个元素设置了transfiom属性之后，这块区域就会被提交给GPU来计算各种位置属性，这就带来了另一个问题，这块区域变成一个类似于独立窗口的区域，其中position:fixed时候，内部元素并不会以视窗作为定位了，而是以被设置部分作为窗口进行定位，所以在设置了transform的元素内部，应该避免使用position:fixed或者按照新的展示方式来使用position:fixed</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/03/24/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/03/24/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">JavaScript事件机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-24 18:51:32" itemprop="dateCreated datePublished" datetime="2021-03-24T18:51:32+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>事件在1997年的HTML4.0中被加入，之后就成为了web技术的核心部分。而js则是通过了事件来对用户的行为进行反应，然后执行 一段代码来实现想要的功能。</p>
<h3 id="JS事件模型"><a href="#JS事件模型" class="headerlink" title="JS事件模型"></a>JS事件模型</h3><h4 id="原始事件模型"><a href="#原始事件模型" class="headerlink" title="原始事件模型"></a>原始事件模型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;click()&quot;&gt;点我&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">const btn = document.getElementById(&#x27;btn&#x27;)</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    //do something</span><br><span class="line">&#125;</span><br><span class="line">//解除事件</span><br><span class="line">btn.onclick = null</span><br></pre></td></tr></table></figure>

<p>这种事件是直接在dom节点上直接绑定，单个dom节点上只能绑定一个，再次绑定会覆盖之前的事件</p>
<p>这种事件只会冒泡传递</p>
<p>####DOM2事件模型 </p>
<img src="/hexo/2021/03/24/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/img.png" class="">
<p>「从网上扒了一张图」<br>如图所示1,2,3为捕获，5,6,7为冒泡，也就是说事件流分为三个阶段：<br>DOM2 级事件模型共有三个阶段：</p>
<p>事件捕获阶段：事件从 document 向下传播到目标元素，依次检查所有节点是否绑定了监听事件，如果有则执行。<br>事件处理阶段：事件在达到目标元素时，触发监听事件。<br>事件冒泡阶段：事件从目标元素冒泡到 document，并且一次检查各个节点是否绑定了监听函数，如果有则执行。</p>
<p>绑定事件的方法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>addEventListener有三个参数 事件名称、事件回调、捕获/冒泡</p>
<h3 id="React事件模型（16-8-0）"><a href="#React事件模型（16-8-0）" class="headerlink" title="React事件模型（16.8.0）"></a>React事件模型（16.8.0）</h3><p>React会将所有的事件都绑定在最外层(document)，使用统一的事件监听，并在冒泡阶段处理事件，当挂载或者卸载组件时，只需要在通过的在统一的事件监听位置增加或者删除对象，因此可以提高效率。并且React并没有使用原生的浏览器事件，而是在基于Virtual DOM的基础上实现了合成事件(SyntheticEvent)，事件处理程序接收到的是SyntheticEvent的实例。SyntheticEvent完全符合W3C的标准，因此在事件层次上具有浏览器兼容性，与原生的浏览器事件一样拥有同样的接口，可以通过stopPropagation()和preventDefault()相应的中断。如果需要访问当原生的事件对象，可以通过引用nativeEvent获得。</p>
<p>由于React内部维护了一个自己的事件池，所以在事件的行为看起来与原始事件模型蕾丝，React在内部维护了合成事件，抹平了事件之间的差异，因此也带来了一些坑点。</p>
<p>由于React只设计了冒泡模式，所有的事件都统一实现了冒泡的效果，所以当react事件与原生事件混用会有些问题</p>
<h4 id="onScroll事件"><a href="#onScroll事件" class="headerlink" title="onScroll事件"></a>onScroll事件</h4><p>onScroll事件是个非常特殊的事件，在浏览器中他是没有冒泡的，在react中，react为了实现一致性 ，利用事件捕获实现了事件的传递</p>
<img src="/hexo/2021/03/24/JavaScript%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/img.png" class="">

<p>也就是说React的onScroll事件如果调用stopPropagation()，会导致事件在图中1号位置就结束了事件传递，这个时候所有的用原生方式添加的onscroll事件都会失去作用，因为事件从document捕获的时候就已经结束了，就没有办法再继续触发了</p>
<p>同时，因为JS是单线程的，页面是只有一条事件传递路线的，react将所有事件委托到document，如果在document上阻止了捕获事件，</p>
<p>就会导致整个页面其他需要捕获传递的事件全部失效</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，js是事件驱动的，各种情况下事件传递略有不同，但还是离不开几个事件模型，如果对于事件模型有比较好的理解，就能解决很多事件上的bug</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/02/22/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/02/22/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">自动化测试学习笔记（2）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-22 19:29:31" itemprop="dateCreated datePublished" datetime="2021-02-22T19:29:31+08:00">2021-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在第一篇里面讲述了如何对与util类型的的纯计算js等方法进行测试，那么如何在react中来使用呢？</p>
<p>这就要提到一个包 Enzyme。</p>
<p>Enzyme 来自 airbnb 公司，是一个用于 React 的 JavaScript 测试工具，方便你判断、操纵和历遍 React Components 输出。</p>
<p>Enzyme 的 API 通过模仿 jQuery 的 API ，使得 DOM 操作和历遍很灵活、直观。Enzyme 兼容所有的主要测试运行器和判断库，文档和例子使用 mocha 和 chai。</p>
<p>本次使用的环境如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mocha-and-chai&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;^17.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha --require babel-core/register ./test/react.test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;</span><br><span class="line">    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;chai&quot;: &quot;^4.3.0&quot;,</span><br><span class="line">    &quot;enzyme&quot;: &quot;^3.11.0&quot;,</span><br><span class="line">    &quot;enzyme-adapter-react-16&quot;: &quot;^1.15.6&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;^8.3.0&quot;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要对react组件进行测试，就得先按转babel-preset-es2015，babel-preset-react，使框架具备对于es6以及react jsx的支持，否则的话单纯mocha是没办法支持react的</p>
<p>然后安装Enzyme对react产生的dom进行模拟</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; shallow &#125; from &#x27;enzyme&#x27;;</span><br><span class="line">import &#123; configure &#125; from &#x27;enzyme&#x27;;</span><br><span class="line">import Adapter from &#x27;enzyme-adapter-react-16&#x27;;</span><br><span class="line">configure(&#123; adapter: new Adapter() &#125;);</span><br></pre></td></tr></table></figure>

<p>shallow方法可以帮我们快速渲染一个dom出来，Adapter对enzyme进行一个基础的配置</p>
<p>这时我们有一个组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">export default class Index extends React.Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;1111&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们开始对他进行愉快的测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;react-test&#x27;, function () &#123;</span><br><span class="line">    const wrapper = shallow(&lt;TestReact /&gt;);</span><br><span class="line">    it(&#x27;should mount right&#x27;, function () &#123;</span><br><span class="line">        expect(wrapper.find(&#x27;div&#x27;).text()).to.equal(&quot;1111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(&#x27;should mount property right&#x27;, function () &#123;</span><br><span class="line">        expect(wrapper.state()).to.equal(null);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过Enzyme ，我们能够找到dom元素，然后对元素进行分析</p>
<p>也可以获取到组件内的属性，对组件的属性进行分析</p>
<p>列举一个场景</p>
<p>在开发sugar的pagination的时候，当选中的元素不同时要渲染出不一样的页码，这个时候就可以通过这种方式来进行测试来保证各种场景的正确性，其中还有选中元素偏离等小逻辑，可以防止后边的同学开发写错</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前端自动化测试整体大致分为以下四类：单元测试、集成测试、ui测试、端到端(e2e)测试/功能测试，虽各有场景，但也在“不同阶段“各有优劣。这里必须强调是“不同阶段”，才会产生不同的选择优劣，因为每一种自动化测试本身，都有其实际不可替代的场景。</p>
<p><strong>1、单元测试</strong><br>单元测试：是指对应用中的最小可测试单元进行检查和验证，通常指的是独立测试单个函数。<br>举一个场景：你现在要改造一个老前端框架，并根据其开发一个向后兼容的新框架。此时老框架针对其内部API函数，写了充分的单测用例。那么，在开发新框架时，直接运行老前端框架的单测用例，偌所有测试用例都通过(PASS)，则可快速保证内部API函数的一致性，快速验证了所有功能场景。</p>
<p>前端单元测试，是所有类型的前端自动化测试中成本较低，且90%以上前端逻辑场景都可覆盖的，非常有效的自动化测试手段。</p>
<p><strong>2、集成测试</strong><br>集成测试：就是测试应用中完全不同的模块(组件)间，如何集成、如何一起工作。这和它的名字一致，用来确保不同组件间互相合作的正确性。</p>
<p>举一个场景：测试在接收到特定的 post 请求以后，数据库会添加对应的记录，那么这就是集成测试，而不是单元测试。 远端发起post请求的服务 和 数据库，就是完全不同的模块。</p>
<p><strong>3、UI 测试</strong><br>UI 测试：是对图形交互界面的测试。UI层是用户使用产品的入口，所有功能通过这一层提供给用户。<br>举一个例子：现在你要对比，“特定页面的视觉样式”是否严格满足“设计师产出的视觉稿”，就涉及到了ui测试。一般会涉及到UI界面的快照(界面截图)对比等。</p>
<p><strong>4、端到端(e2e)测试</strong><br>端到端(e2e)测试/功能测试：是站在用户角度的测试，把我们的程序看成是一个黑盒子，用来确保整个应用会按照用户期望的那样运行。</p>
<p>不关心代码内部的实现，只负责打开浏览器，把测试用例中设置的内容在页面上输入一遍，看是不是得到想要得到的结果。</p>
<p><strong>适当把单元测试，集成测试、UI测试和e2e测试，按照发布上线前的不同阶段进行互相隔离后，可以在开发的不同阶段分别运行它们，进而全面的保障应用的稳定性。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yxsgithub.github.io/hexo/2021/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.gif">
      <meta itemprop="name" content="yuxiao">
      <meta itemprop="description" content="振翅">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Moonkin's Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/hexo/2021/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">自动化测试学习笔记（1）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-21 18:53:42" itemprop="dateCreated datePublished" datetime="2021-01-21T18:53:42+08:00">2021-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 10:32:24" itemprop="dateModified" datetime="2025-06-09T10:32:24+08:00">2025-06-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">工具分享</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/hexo/categories/%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">插件分享</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是讲述如何对 js方法进行自动化测试</p>
<p>产生这个需求是因为之前的jsbridge开发，需要稳定演进api，并保证之后的改动不出错，所以需要引进自动化测试的内容用于自测，降低开发自测成本</p>
<p>选用的框架是 Mocha.js 和chai.js</p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="首先准备工具"><a href="#首先准备工具" class="headerlink" title="首先准备工具"></a>首先准备工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;mocha-and-chai&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">    &quot;chai&quot;: &quot;^4.2.0&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;^6.1.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;node ./node_modules/mocha/bin/mocha --require babel-core/register ./test/LotteryCalculation.test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中babel是帮我们 es6转es5。</p>
<p>mocha是一个功能丰富的javascript测试框架。</p>
<p>Chai是一个用于node和浏览器的BDD / TDD断言库，可以与任何javascript测试框架搭配使用。</p>
<p>这些准备好之后就可以准备开始一个单元测试了</p>
<h3 id="准备一个待测试的方法"><a href="#准备一个待测试的方法" class="headerlink" title="准备一个待测试的方法"></a>准备一个待测试的方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param type</span><br><span class="line"> * @param a &#123;number&#125;</span><br><span class="line"> * @param b &#123;number&#125;</span><br><span class="line"> * @returns &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">export default function (type, a, b) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &quot;+&quot;:</span><br><span class="line">            return a + b;</span><br><span class="line">        case &quot;-&quot;:</span><br><span class="line">            return a - b;</span><br><span class="line">        case &quot;*&quot;:</span><br><span class="line">            return a * b;</span><br><span class="line">        case &quot;/&quot;:</span><br><span class="line">            return a / b;</span><br><span class="line">        default:</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有这样一个方法，根据type值来计算ab的加减乘除,我们来对他进行测试</p>
<p>这个时候首先要用mocha.js，我理解mocha是帮我们管理我们的测试任务的，所以下面是这个样子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;test&#x27;, function () &#123;</span><br><span class="line">    it(&#x27;should get right value&#x27;, function () &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这块不需要引入mocha的包，因为我们会用mocha来运行它，describe是描述一个总任务，it则是用来描述一个小的任务项</p>
<img src="/hexo/2021/01/21/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/WX20210121-204359@2x.png" class="">

<p>下一步是测试我们的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(&#x27;test&#x27;, function () &#123;</span><br><span class="line">    it(&#x27;should get right value&#x27;, function () &#123;</span><br><span class="line">         expect(MochaTestFun(&#x27;+&#x27;,1,1)).to.equal(2)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个时候就轮到了chai.js中的expect上场。expect是BDD风格（Behavior Driven Development,行为驱动开发）的，使用链式语言来组织断言。</p>
<p>断言库在测试中很重要，是用来帮我们判断某些行为。例如判断类型，值的比较，错误捕获。通常情况下断言库都比较与自然语言相通</p>
<p>在这段测试语句里面我期望方法的结果为2</p>
<p>然后就是批量写一些测试数据然后进行批量测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import MochaTestFun from &quot;../app/MochaTestFun&quot;;</span><br><span class="line">import &#123;expect&#125; from &quot;chai&quot;</span><br><span class="line">let testDataList=[</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;a+b&quot;,</span><br><span class="line">        type:&#x27;+&#x27;,</span><br><span class="line">        a:1,b:1,</span><br><span class="line">        value:2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;a-b&quot;,</span><br><span class="line">        type:&#x27;-&#x27;,</span><br><span class="line">        a:1,b:1,</span><br><span class="line">        value:0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;a*b&quot;,</span><br><span class="line">        type:&#x27;*&#x27;,</span><br><span class="line">        a:1,b:1,</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name:&quot;a/b&quot;,</span><br><span class="line">        type:&#x27;/&#x27;,</span><br><span class="line">        a:1,b:1,</span><br><span class="line">        value:1</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line">describe(&#x27;test&#x27;, function () &#123;</span><br><span class="line">    it(&#x27;should get right value&#x27;, function () &#123;</span><br><span class="line">        for (let i = 0; i &lt; testDataList.length; i++) &#123;</span><br><span class="line">            const item = testDataList[i];</span><br><span class="line">            expect(MochaTestFun(item.type,item.a,item.b)).to.equal(item.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后有的同学就有疑问，这样做的好处都有啥呢？</p>
<p>代码刚写出来的时候自测完基本不会出问题，但是呢，产品经理总要改需求，比如加减乘除最大结果不得超过100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default function (type, a, b) &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case &quot;+&quot;:</span><br><span class="line">            return Math.min(a + b,100);</span><br><span class="line">        case &quot;-&quot;:</span><br><span class="line">            return Math.min(a - b,100);</span><br><span class="line">        case &quot;*&quot;:</span><br><span class="line">            return Math.min(a * b,100);</span><br><span class="line">        case &quot;/&quot;:</span><br><span class="line">            return Math.min(a / b,100);</span><br><span class="line">        default:</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以补充相应的测试用例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       name:&quot;加减乘除的结果不得超过一百&quot;,</span><br><span class="line">       type:&#x27;+&#x27;,</span><br><span class="line">       a:100,b:1,</span><br><span class="line">       value:100</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>当其他同学更改这块代码的逻辑之后，跑一下测试用例，就不会影响之前的逻辑，一些奇怪的写法导致的结果也会被保存。保证了代码上线之后的安全。</p>
<p>实际上mocha和chai可以做的更多，可以查看</p>
<p><a target="_blank" rel="noopener" href="https://mochajs.cn/#getting-started">https://mochajs.cn/#getting-started</a></p>
<p><a target="_blank" rel="noopener" href="https://www.chaijs.com/api/">https://www.chaijs.com/api/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/hexo/page/2/">2</a><a class="extend next" rel="next" href="/hexo/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">yuxiao</p>
  <div class="site-description" itemprop="description">振翅</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/hexo/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuxiao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/hexo/lib/anime.min.js"></script>
  <script src="/hexo/lib/velocity/velocity.min.js"></script>
  <script src="/hexo/lib/velocity/velocity.ui.min.js"></script>

<script src="/hexo/js/utils.js"></script>

<script src="/hexo/js/motion.js"></script>


<script src="/hexo/js/schemes/muse.js"></script>


<script src="/hexo/js/next-boot.js"></script>




  















  

  

</body>
</html>
